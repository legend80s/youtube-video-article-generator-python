import asyncio
import os
import sys
import unittest

# Add the parent directory to the path so we can import youtube_info and youtube_models
sys.path.append(os.path.join(os.path.dirname(__file__), "..", "..", ".."))

from app.lib.tools.youtube_info import fetch_transcript, YouTubeId


class TestYouTubeTranscript(unittest.TestCase):
    def test_fetch_transcript(self):
        transcript = asyncio.run(fetch_transcript(YouTubeId.of("4KdvcQKNfbQ")))

        # print(f"{transcript=}")

        expected = """This is the most important property of exclusive or operation also known as zor. If you apply the same value twice, you get the original value. And to demonstrate that this is actually true, we can bust out Python and take all of the possible combinations of two beats. So let's take a in a range from 0 to 1 and b in a range from 0 to 1. And let's take all of the possible combinations of them. Let's literally plug in this formula and confirm that it is true for each individual combination of A and B. And if this formula works for just one bit, that means it works for every single bit of any integer. This has profound implications. For example, this is a simple encryption algorithm actually, believe it or not. So if you have some sort of a message, let's say hello world, you can take each individual character of that message and turn it into an integer of course and let's define some sort of a key and if you zor that with a key you get an encrypted message. Obviously you can turn each individual integer back into a character and then join all of the characters together and you basically get a very simple encryption algorithm. So let's actually wrap that into a function encrypt. It is going to accept message and the key and is going to apply the algorithm and return the result. So if you encrypt the message with the key 69, here's the result. Let's assign it to a variable encrypted message. And to decrypt this message, you use the same algorithm with the same key. If you use a wrong key, excuse me, if you use a wrong key, you're not going to get the same message back. Only if you use the correct key, you'll get this message back. This encryption algorithm is actually still vulnerable to all sorts of attacks including frequency analysis and stuff like that. So I do not recommend using in production. But that's besides the point. It is still a very rudimentary encryption algorithm. Another interesting patchy trick this specific property enables is an ability to swap a value of two variables without using any intermediate variables. Well, in such languages as Python, it is rather easy to swap the value of two variables. Right? So essentially you can just do something like this and there you go you you swapped the value of two variables but in older languages like C it is not that straightforward because it doesn't have multiple assignment doesn't have pupils or anything like that. Let's actually create a C program. Let's include std and let's create an entry point. So let's define two variables A and B. Let's bring them super quick. And usually the first thing people do when they try to swap the value of two variables, they just allocate two variables. So they assign B to X, A to Y, and then assign them back. And there you go. You swapped two variables. Let's compile this entire thing and run it. That's not correct. Ah, I put a line after the print. Excuse me. There we go. So this works obviously, right? But the first sort of algorithmic exercise that gives people who learn programming actual algorithmic experience is to ask them to solve this problem using only one intermediate variable. In real life, it is not important how exactly you achieve that. So it's not like you're wasting too much memory. Memory is cheap. Well, that phrase didn't really age that well, but still additional 32-bit integer is is not going to hurt. It's it's kind of an interesting exercise to try to do that with only one intermediate variable. And the way you do that is you just assign any of the two variables to an intermediate variable and you realize that you just saved the value of that variable. Since you save the value of that variable, you should not be afraid to lose that value. So you can immediately reassign this variable and now you can restore the value of that variable back to the second variable. And there you go. You wrote this algorithm with only one intermediate variable. You can actually start with any variable. You can actually start with B. You can realize that you save the value of B. So you can override it and then you can restore that value back with T. There you go. It still works. It doesn't matter. You can do that in any order. The property of Zor, this specific property of Zor enables you to swap the value of two variables without using any intermediate variables. How does it work? Right? Now a is equal to 69 and B is equal to 420. If you do a zor b, you end up with a equal 69 zor 420 and b equal 420. Okay. Then if you try to do B zor A, you're going to end up with B looking like this. Another interesting property of Zor is that it's commutative. So that means the order of operation doesn't matter. You can swap some of the operants and you end up with a very interesting situation where for 20 actually cancels itself. Okay, that's pretty cool. So the next operation you do a zor b and you end up with a looking like this. Again, commutative order doesn't matter. and we end up with a very interesting situation where 69 nuked itself and we just swapped the value of the variables without using any intermediate variables. Still works. It's not like it's useful in real world programming. The compiler will try to do its own thing anyway trying to infer your intent, but it's kind of again nice exercise, nice potty trick. Another party trick that I actually quite often see in coding interview and I don't really understand why interviewers ask this kind of thing is finding a duplicate element. If you ever did a coding interview, you're probably familiar with that sort of exercise. So let's take a look at it. Let's create another C program with an entry point and let's generate numbers from one to 100. Let's literally print them like so. Now let's say that one of the elements is actually duplicated. For example, 69. So if we encounter 69, simply print that 69 twice. All right. You are given an array like that where you have all the numbers from 1 to 100 consequently except one element is duplicated and you have to find what element is duplicated as efficiently as possible preferably in a linear time. Well, given that the array is sorted, it's it's very easy. You just iterate it linearly. But what if it is not sorted? You have to sort it. But sorting is going to be an n login. And in this specific case, we kind of know that it is 69, right? So because we generated this test case but what if we don't know what if we say that this entire thing is literally random a random value from 1 to 100 and I'm going to even set the seat to the current time so it is different every time I run this program does actually include lib for the random and time for the time. All right so right now I don't even know which one is duplicated. So let's go ahead and actually join all of the lines with a comma. Let's copy paste this thing and assign it to some sort of an array like this. We have to write an algorithm that finds the duplicate as optimally as possible. And the idea here is to use this property of zor. You see, we can just go ahead and iterate all of the values from 1 to 100, right? Because we know that it contains the numbers for 1 to 100. And we can just simply zore all of them together like so. Then if we start iterating through this array of X's, let's actually find its size. So we have to take the size of the entire array, but it's going to give us the size in bytes. So we have to divide it by the size of a single element in bytes. So iterating from 0 to n and then we're zoring that specific x with each individual element from that array. So what is going to happen? X is currently one zor 2 zor 3 zor 4 and so on and so forth. So you are start zoring it with the elements of that array and you start nuking each individual element one by one one by one until you nuke each individual element and then you're going to end up with zero and the last duplicate element let's call it y is going to be zero zor that duplicate y and any value zor zero is that element. So the result is going to be that duplicate element. So let's go ahead and print it. And it's 13 and and it is 13. Look at that. It is duplicated. None of the other elements are duplicated. Only 13. So that's how we do that. I'm giving away how to solve this problem because I absolutely hate it because it tests nothing. It doesn't test your ability to code. It just tests whether you know this gimmick or not. And unfortunately, a lot of coding interviews are like that. They test nothing. But if you put that aside, it is still a kind of cool potty trick. Again, pretty cool patty trick. I like it. Another py trick that is enabled by this specific property of zor is probably something like zor linked list. In a classical doubly linked list, you have a sequence of nodes and each node has a reference to the next node and to the previous node. The nodes at the beginning at the end have a previous node equal to null. So the idea of zor linked list is instead of storing two pointers store only one pointer which is just a zor between the addresses of the previous pointer and the next pointer. None of the nodes have a direct reference to any other nodes, but they have this single number which cuts the memory usage of the entire link list in half excluding the payload, excluding the value stored in the in the node. And the way you iterate this list is by keeping track of the previous value. So let's call this zord value zord. If you know the current node and the previous pointer of that node, you can always take zord and zor of the previous value of this specific previous value and you find the next value. You literally utilizing this property to restore the next value and by keeping track of the previous node, you can iterate this list like that, which is kind of cool. Again, it's not like you're going to be using that in in production or in real world, but again, it's kind of a cool gimmick. Let's implement it. I'm going to include the std anyway. So, let's define a single node. That node is going to store a payload, a value, and a zord value between the previous pointer and the next pointer. We're going to be using a special type which is called u inpointer t called zord. And it's an interesting type. It's a integer specifically an integer but its size is exactly the size of the pointer. So it's specifically designed to store addresses of pointers which is exactly our case. So we're going to be allocating the nodes on the heap. So let's create some sort of helper which basically creates a new node given the value and it returns you pointer to the node allocated on the heap. So we're going to do malo and let's take size of the node and let's assign it to the node that we allocated. In fact, I would like to maybe take a size of of the dreference node. So if I change ever change the type of this thing I didn't have to change it in here. Not like I'm going to be maintaining this code, but still. Uh so after that, let's actually set the whole thing to zero. So let's zero initialize this entire stuff and let's set the value to value. An interesting thing is that the value of zord equal to zero means that the previous and the next is zero because zord zero is zero. So just zord being zero indicates that you don't have neither next nor previous. It's a standalone node. And let's just return this node. Let's define the linked list itself. Linked. So the link list itself is going to keep track of the begin node and the end node. So you you know at least from where to iterate. And let's implement only one single operation for link list to keep the scope of this entire video a little bit smaller. And I'll append. Let's only implement append. So we're going to take a pointer to the linked list and the value that you want to append in here. There's two situations that can happen in a doubly linked list is that when the list is empty, meaning that something like end or begin is equal to null. In fact, if one of them is equal to null, that means the other one also has to be equal to null. We might want to assert this specific case. If one of them is equal to no, another one is not equal to null. The list is just in a weird state. We don't want to deal with that. And I don't want to focus on implementing this thing yet. So let's actually say that it's not implemented. I want to work on the case when you have at least one element in the list because in that case you have something in the end. The zord value of the end is probably going to be equal to something like previous zord zero or null because the end doesn't have the next. So it's previous zor zero. But what's interesting is that any value zor zero is that value. So that means zord is equal exactly to previous. There's nothing we can do with that right now, but it's just like nice to know. Let's allocate a node on a heap. Let's allocate the node. This is the node and node create. And I'm just like pushing a value in here. So I allocated a new node. Let's maybe pick a different color. This is the new node. So what I have to do I have to point its previous value to the end. It doesn't have a next value. So that means it's going to be something like end zor zero which means we have to take the value of the end and simply assign it to zord of the node obviously casting it to your int pointer. Okay. So that should be sufficient. Now we have to redirect the next value of the end to this node. But as of right now that next value is equal to zero. So and as we already said that zord is literally equal to previous. So to actually set the previous value to the node we have to do zor the pointer to that new node. Obviously casting it to the int pointer t. All right the last thing we have to point the end to the new node. We can also align it like that. That should be it. In case of the list being empty, what we want to do, we want to probably also allocate a new node and instantly set it to the end and maybe set begin to the end as well. So this one is actually rather simple, right? We don't even have to set zor to anything, right? So this is the first element. As soon as you allocate a first element, both begin and end are going to be pointing at the same that element. And then if you push more, you're going to be going into that branch. So that should be it actually. So let's allocate the linked list on the stack in here. zero initialize it of course let's iterate from five to let's say 10 and let's keep pushing the elements into here let's try to run the whole thing okay let's go through the compilation errors so for that thing it needs to have std int also for the maloc it needs to have standard library that's understandable for the mems set it needs to have string and I think for the assert it also needs assert so that's all of the things there we go so and it didn't crash at least right so there's no segmentation fault now we need to iterate this entire thing when we're only starting to iterate the previous value is obviously equal to zero let's assign an iterator let's take the begin how can we get the next note what we have to do we have to take zord then zord it with the previous and that will give us the pointer to the next so we have to reassign it like that and that's the next and we have to keep doing that until we encounter zero It would be kind of nice to organize some sort of a for loop. What I'm thinking is that we could have do something like this. So this is initialization. We keep doing that while eater is not new and then on each iteration we do something like that. Problem here is that we also need to update the previous accordingly. So let's create a helper function something like node next. It is going to accept the current node and it's going to return you the next node. But to compute the next node, it needs the address of the previous one. And as it computes the next one, it also should update the value of the previous one. It is going to do this computation to compute the next one. And it's going to return you the next one. But on top of that, it is going to update the previous value with the value of the current node. And that way it computes the next one and keeps track of the previous. So in here, we can now go ahead and print the value of each individual node. It's not eater. It's actually node. All right. Yeah, this is a pointer. I forgot to reference this entire thing. There we go. And it's seculted. Perfect. Ah, of course I forgot to call this function. And now it works. It iterates the elements from five to 10. What's interesting is that if you set the initial value to end, it will iterate the list in a reverse order. The reason being is that the previous value of the begin is null and the previous the value of the end is null as well. So somehow picking the initial node also defines a direction of iteration even though you explicitly never really defined it. It is kind of cool actually. And all of that was made possible by this small property which sometimes is actually written like this. But but I don't like this way of writing this property because it kind of hides the intent. It kind of hides the implications. If you write it like this, it tells you the implications very explicitly and I kind of like that. So do you know any other applications of this specific property of Zor? I'm pretty sure there's like an infinite of them. I only wish they start asking this in according interviews."""
        self.assertEqual(transcript, expected)


if __name__ == "__main__":
    # 运行所有测试
    unittest.main(verbosity=2)
